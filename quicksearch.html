<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"base.js.html":{"id":"base.js.html","title":"Source: base.js","body":" grasshopper3d.js Classes GHCompGHParamGHRenderGHSolution Tutorials Arc through 3 pointsCircle through 3 points3D CubeDraggable PointMidpoints Source: base.js // Lionel du Peloux - 2016 // Licence : MIT // parameters are objects that store datas // components are objects that acte on datas // global variables to trace refresh var debug = false var log_register = false var log_statut = false var log_refresh = false var display_decimal = 3 var arc_as_cbcurve = false // if true, arc and circles are approximated as Cubic Bezier Curves // ============================================================================= // BASE CLASSES // ============================================================================= // Generic Parameter (base class) /** * Represents a book. * @constructor * @param {string} title - The title of the book. * @param {string} author - The author of the book. */ class GHParam { constructor(type){ this.id = -1 // unique id = 0, ..., N this.type = type // param type this.isupdated = true // false if the value is waiting to be computed this.isroot = false // true if this is a root parameter (default to false) this.comp_out = [] // register all dependents components this.svg_out = [] // register all dependents svgobj } } Object.defineProperties(GHParam.prototype, { 'register_comp': { // register an output parameter no needs to bind configurable: false, value: function(comp) { this.comp_out.push(comp) return comp } }, 'register_svg': { // register an svg parameter no needs to bind configurable: false, value: function(svg) { this.svg_out.push(svg) return svg } }, 'hasChanged': { // raise &quot;hasChanged&quot; event =&gt; compute new statuts and recompute solution value: function() { if (log_statut || log_refresh) { console.log(&quot;===============================&quot;) console.log(&quot; RECOMPUTE SOLUTION &quot;) console.log(&quot;&quot;) } if (log_statut) { console.log(&quot;*** broadcast statut ***&quot;) } this.spreadStatut(); if (log_refresh) { console.log(&quot;&quot;) console.log(&quot;*** broadcast refresh ***&quot;) } this.spreadRefresh()} }, 'refresh': { value: function() {} }, 'spreadRefresh': { value: function() { this.refresh() this.isupdated = true if (log_refresh) { console.log(&quot;Param[&quot; + this.type + '-' + this.id + &quot;] : isupdated = &quot; + this.isupdated) } for (var i = 0; i &lt; this.comp_out.length; i++) { this.comp_out[i].spreadRefresh() } for (var i = 0; i &lt; this.svg_out.length; i++) { this.svg_out[i].spreadRefresh() } } }, 'spreadStatut': { value: function() { this.isupdated = false if (log_statut) { console.log(&quot;Param[&quot; + this.type + '-' + this.id + &quot;] : isupdated = &quot; + this.isupdated) } for (var i = 0; i &lt; this.comp_out.length; i++) { this.comp_out[i].spreadStatut() } for (var i = 0; i &lt; this.svg_out.length; i++) { this.svg_out[i].spreadStatut() } } } }) // Generic Component (base class) /** * Represents a GHComp. * @constructor * @param {string} title - The title of the book. * @param {string} author - The author of the book. */ class GHComp { constructor(id, name){ this.id = id // unique id = 0, ..., N this.name = name // component name this.isupdated = true // false if the value is waiting to be computed this.param_in = [] // register all input parameters this.param_out = [] // register all output parameters } } Object.defineProperties(GHComp.prototype, { 'register_in': { // resgister an input parameter and bind it to the component configurable: false, value: function(param) { this.param_in.push(param) param.register_comp(this) return param } }, 'register_out': { // resgister an output parameter no needs to bind configurable: false, value: function(param) { this.param_out.push(param) return param } }, 'refresh': { configurable: true, value: function() {} // to be overrided in components }, 'spreadRefresh': { configurable: false, value: function() { // wait till all input parameters have been refreshed for (var i = 0; i &lt; this.param_in.length; i++) { if (this.param_in[i].isupdated == false) { return } } // refresh should not be propagated more than once if (this.isupdated == true) { return } // otherwise, the component is ready to be refreshed this.refresh() this.isupdated = true if (log_refresh) { console.log(&quot;Comp[&quot; + this.id + &quot;] : isupdated = &quot; + this.isupdated) } for (var i = 0; i &lt; this.param_out.length; i++) { this.param_out[i].spreadRefresh() } } }, 'spreadStatut': { configurable: false, value: function() { // statut should not be propagated more than once if (this.isupdated == false) { return } // otherwise, the component is hit by a statut switch and must propagate the spreadStatut process this.isupdated = false if (log_statut) { console.log(&quot;Comp[&quot; + this.id + &quot;] : isupdated = &quot; + this.isupdated) } for (var i = 0; i &lt; this.param_out.length; i++) { this.param_out[i].spreadStatut() } } } }) // Generic SVG (base class) class GHSvg { constructor(paper, viewport, id, name){ this.id = id // unique id = 0, ..., N this.name = name // component name this.paper = paper // reference to snap object this.isupdated = true // false if the value is waiting to be computed this.viewport = viewport // global transformation matrix to apply for drawing 3D to 2D this.param_in = [] // register all input parameters this.svgobj = [] // a coolection of snapsvg elements this.grp = undefined // if several svgobj they should be grouped ? // put generic logic here for drag&amp;drop // and animation callbacks on load } } Object.defineProperties(GHSvg.prototype, { 'register_in': { // resgister an input parameter and bind it to the component configurable: false, value: function(param) { this.param_in.push(param) param.register_svg(this) return param } }, 'register_svg': { // resgister a snap cvg element configurable: false, value: function(svg) { this.svgobj.push(svg) return svg } }, 'refresh': { configurable: true, value: function() {} // to be overrided in components }, 'spreadRefresh': { configurable: false, value: function() { // wait till all input parameters have been refreshed for (var i = 0; i &lt; this.param_in.length; i++) { if (this.param_in[i].isupdated == false) { return} } // refresh should not be propagated more than once if (this.isupdated == true) { return } // otherwise, the component is ready to be refreshed this.refresh() this.isupdated = true if (log_refresh) { console.log(&quot;Svg[&quot; + this.id + &quot;] : isupdated = &quot; + this.isupdated) } } }, 'spreadStatut': { configurable: false, value: function() { // statut should not be propagated more than once if (this.isupdated == false) { return } // otherwise, the component is hit by a statut switch and must propagate the spreadStatut process this.isupdated = false if (log_statut) { console.log(&quot;Svg[&quot; + this.id + &quot;] : isupdated = &quot; + this.isupdated) } } }, 'group': { // group all svgobj value: function(options) { if (this.grp === undefined) {this.grp = this.paper.group()} for (var i = 0; i &lt; this.svgobj.length; i++) { this.grp.add(this.svgobj[i]) } return this } }, 'attr': { value: function(options) { for (var i = 0; i &lt; this.svgobj.length; i++) { this.svgobj[i].attr(options) } return this } }, 'addClass': { value: function(str) { if (this.grp === undefined) { // add attr to all elements for (var i = 0; i &lt; this.svgobj.length; i++) { this.svgobj[i].addClass(str) } } else { // a group exists, add it to the grp this.grp.addClass(str) } return this } }, 'toGroup': { value: function(grp) { if (this.grp === undefined) { // add all elements to grp for (var i = 0; i &lt; this.svgobj.length; i++) { grp.add(this.svgobj[i]) } } else { // a group exists, add it to the grp grp.add(this.grp) } return this } }, 'svg': { get: function() { return this.svgobj }, set: function(val) { return this.svgobj = val }, }, }) // ============================================================================= // SOLUTION // ============================================================================= // Solution class /** * Represents a book. * @constructor * @param {string} title - The title of the book. * @param {string} author - The author of the book. */ class GHSolution { constructor(){ this.param_root = [] // solution's root parameters - have no parents - may have 0 to N childs this.param_comp = [] // solution's not-root parameters - auto generated by components - must not be edited this.comp = [] // register all dependent components this.isupdated = true // false if the solution needs to be recomputed } } // GHParameters Methodes Object.defineProperties(GHSolution.prototype, { 'RegisterRootParam': { value: function(param) { param.id = this.param_root.length this.param_root.push(param) param.isroot = true return param } }, 'Number': { value: function(num) { return this.RegisterRootParam(new GHNumber(num)) } }, 'Point': { value: function(x, y, z) { return this.RegisterRootParam(new GHPoint(x, y, z)) } }, 'Vector': { value: function(x, y, z) { return this.RegisterRootParam(new GHVector(x, y, z)) } }, 'Plane': { value: function(origin, xaxis, yaxis) { return this.RegisterRootParam(new GHPlane(origin, xaxis, yaxis)) } }, 'Circle': { value: function(plane, r) { return this.RegisterRootParam(new GHCircle(plane, r)) } }, 'Arc': { value: function(plane, r, a1, a2) { return this.RegisterRootParam(new GHArc(plane, r, a1, a2)) } }, 'Polyline': { value: function(points) { this.RegisterRootParam(new GHPolyline(points)) } }, }) // GHComponents Methodes Object.defineProperties(GHSolution.prototype, { 'RegisterComp': { value: function(comp) { // register comp newly created param_out parameters for (var i = 0; i &lt; comp.param_out.length; i++) { var param = comp.param_out[i] param.id = this.param_comp.length this.param_comp.push(param) } // register comp this.comp.push(comp) } }, 'MidPoint': { value: function(ghp1, ghp2) { var comp = new GHComp_Pts_Mid(this.comp.length, ghp1, ghp2) this.RegisterComp(comp) return comp } }, 'Circle3pts': { value: function(ghps, ghpc, ghpe) { var comp = new GHComp_Circle_3pts(this.comp.length, ghps, ghpc, ghpe) this.RegisterComp(comp) return comp } }, 'Arc3pts': { value: function(ghps, ghpc, ghpe) { var comp = new GHComp_Arc_3pts(this.comp.length, ghps, ghpc, ghpe) this.RegisterComp(comp) return comp } }, 'PolylineFromPts': { value: function(pts) { var comp = new GHComp_Polyline(this.comp.length, pts) this.RegisterComp(comp) return comp } }, }) // ============================================================================= // RENDER // ============================================================================= // Render class /** * Represents a book. * @constructor * @param {string} title - The title of the book. * @param {string} author - The author of the book. */ class GHRender { constructor(width=710, height=400, htmltag){ this.viewport = Matrix.identity() // global transformation matrix to apply for drawing 3D to 2D this.comp_svg = [] // register all ghsvg instances in the current render this.isupdated = true // false if the render needs to be redrawn // create cartesian centered snap paper with a border this.width = width this.height = height this.paper = Snap(this.width,this.height) this.mastergrp = this.paper.g() .attr({id:&quot;cartesian&quot;}) .attr({transform:&quot;translate(&quot;+this.width/2+&quot;,&quot;+this.height/2+&quot;) scale(1,-1)&quot;}) this.borderbox = this.paper.rect(-this.width/2, -this.height/2, this.width, this.height) .attr({strokeWidth:&quot;1px&quot;, stroke:&quot;black&quot;, fill:&quot;none&quot;}) this.mastergrp.add(this.borderbox) // append the paper to the given htmltag if (htmltag === undefined) {} else { this.paper.attr({style:'display:block; margin:auto'}) Snap(htmltag).append(this.paper) } // how to deal with groups ? // how to deal with markers ? // how to deal with defs ? } } // GHRender Methodes Object.defineProperties(GHRender.prototype, { 'registerSvg': { value: function(ghsvg) { ghsvg.toGroup(this.mastergrp) this.comp_svg.push(ghsvg) } }, 'redraw': { // to be called after a change of viewport value: function() { for (var i = 0; i &lt; this.comp_svg.length; i++) { this.comp_svg[i].refresh() } } }, 'setViewport': { value: function(viewport) { this.viewport._setData(viewport) this.redraw() } }, 'Point': { value: function(ghpoint, r) { var ghsvg = new GHSvg_Point(this.paper, this.viewport, this.comp_svg.length, ghpoint, r) this.registerSvg(ghsvg) return ghsvg } }, 'Polyline': { value: function(ghpolyline) { var ghsvg = new GHSvg_Polyline(this.paper, this.viewport, this.comp_svg.length, ghpolyline) this.registerSvg(ghsvg) return ghsvg } }, 'Circle': { value: function(ghcircle) { var ghsvg = new GHSvg_Circle(this.paper, this.viewport, this.comp_svg.length, ghcircle) this.registerSvg(ghsvg) return ghsvg } }, 'Arc': { value: function(gharc) { var ghsvg = new GHSvg_Arc(this.paper, this.viewport, this.comp_svg.length, gharc) this.registerSvg(ghsvg) return ghsvg } }, }) × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" grasshopper3d.js Classes GHCompGHParamGHRenderGHSolution Tutorials Arc through 3 pointsCircle through 3 points3D CubeDraggable PointMidpoints Classes Classes GHComp GHParam GHRender GHSolution × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" grasshopper3d.js Classes GHCompGHParamGHRenderGHSolution Tutorials Arc through 3 pointsCircle through 3 points3D CubeDraggable PointMidpoints Tutorials Classes GHComp GHParam GHRender GHSolution × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" grasshopper3d.js Classes GHCompGHParamGHRenderGHSolution Tutorials Arc through 3 pointsCircle through 3 points3D CubeDraggable PointMidpoints grasshopper3d.jsThis library written in javascript makes easier the production of geometric drawings to explain scientific concepts. It is deeply inspired from grasshopper3d and offers the same ability to construct parametric geometric models. ToDo [ ] implement a global viewport projection matrix (3D =&gt; 2D) [ ] implement a GHSolution = {GHParma + GHComp} with global ids [ ] implement a GHViewport = {GHSvg} [ ] implement : circle and arc GHParam [ ] implement : bezier curve GHParam [ ] investigate arrowhead and usage Main functionalities parametric modeling : your drawings are adaptable, ready to be printed in various configurations, and ready to be animated in the browser SVG output : your drawings are vectoriel, ready for the web, in an open standard CSS : share a single css style sheet for your drawings to ensure coherence through all your drawings LaTeX labels : with MathJax type your labels in LaTeX format animation ready : animate your drawings with GSAP interactive ready: your drawings are ready to deal with user interactions (mouse hover / clic / drag&amp;drop ...) Dependenciesgrasshopper3d.js relies on several simple but clever libraries that I found on github. They are listed here for credits : Snpa.Svg : snap is the core lib for manipulating svg elements in javascript. lightgl.js : I use Vector.js for internal representation of points and vectors and Matrix.js for internal representation of matrix. This library is helpful to set up rotation and projection matrix to draw 3D geometries on the XY plane. bezier.js : A nodejs and client-side library for (cubic) Bezier curve work. [interpolation.js] : An adaptation of my own of this gist catmullFitter.js for interpolating a polyline with cubic bezier curves DocumentationBuild the docThe API documentation is autogenerated from the comments in the code using jsdoc3. To build the docs install execute the following bash command from the repo's root : $ gruntPublish the docThe api doc is published through github-pages. Follow instructions here to push the sources on the master branch and the api subfolder on the gh-pages branch Resources Observer Pattern : a useful guide that explains the main pattern used in grasshopper3d.js. Observer Pattern : help on binding context for events. TutorialsAvailable examples: Simple rotating cube Multitexturing First person camera Scene manipulation OpenGL immediate mode Rendering to a texture Shadow map from a point light Realtime raytracing Constructive solid geometry GPU lightmap generation × Search results Close "},"GHComp.html":{"id":"GHComp.html","title":"Class: GHComp","body":" grasshopper3d.js Classes GHCompGHParamGHRenderGHSolution Tutorials Arc through 3 pointsCircle through 3 points3D CubeDraggable PointMidpoints Class: GHComp GHComp Represents a GHComp. new GHComp(title, author) Parameters: Name Type Description title string The title of the book. author string The author of the book. Source: base.js, line 106 × Search results Close "},"GHParam.html":{"id":"GHParam.html","title":"Class: GHParam","body":" grasshopper3d.js Classes GHCompGHParamGHRenderGHSolution Tutorials Arc through 3 pointsCircle through 3 points3D CubeDraggable PointMidpoints Class: GHParam GHParam Represents a book. new GHParam(title, author) Parameters: Name Type Description title string The title of the book. author string The author of the book. Source: base.js, line 26 × Search results Close "},"GHRender.html":{"id":"GHRender.html","title":"Class: GHRender","body":" grasshopper3d.js Classes GHCompGHParamGHRenderGHSolution Tutorials Arc through 3 pointsCircle through 3 points3D CubeDraggable PointMidpoints Class: GHRender GHRender Represents a book. new GHRender(title, author) Parameters: Name Type Description title string The title of the book. author string The author of the book. Source: base.js, line 407 × Search results Close "},"GHSolution.html":{"id":"GHSolution.html","title":"Class: GHSolution","body":" grasshopper3d.js Classes GHCompGHParamGHRenderGHSolution Tutorials Arc through 3 pointsCircle through 3 points3D CubeDraggable PointMidpoints Class: GHSolution GHSolution Represents a book. new GHSolution(title, author) Parameters: Name Type Description title string The title of the book. author string The author of the book. Source: base.js, line 297 × Search results Close "},"tutorial-arc3pts.html":{"id":"tutorial-arc3pts.html","title":"Tutorial: Arc through 3 points","body":" grasshopper3d.js Classes GHCompGHParamGHRenderGHSolution Tutorials Arc through 3 pointsCircle through 3 points3D CubeDraggable PointMidpoints Arc through 3 points This tutorial shows an arc going through 3 points. In fact, there exists a unique circle going trough 3 non aligned points. The red points are draggables. The parametric solution is animated with GSAP but the model is still draggable. // SET UP THE PARAMETRIC MODEL var s = new GHSolution() var a = 100 var angle = 90*3.14/180 var x = a*Math.cos(angle) var y = a*Math.sin(angle) var p1 = s.Point(-1.5*a,a/2,0) var p2 = s.Point(0,a/2,0) var p3 = s.Point(x,a/2+y,0) var cp3 = s.Arc3pts(p1,p2,p3) // SET UP THE RENDER var r = new GHRender(600,400,'#example') var svgarc = r.Arc(cp3.arc).addClass('line') var svgp1 = r.Point(p1, 10).addClass('node-red') var svgp2 = r.Point(p2, 10).addClass('node-red') var svgp3 = r.Point(p3, 10).addClass('node-red') var svgp4 = r.Point(cp3.center, 5).addClass('line') // ANIMATE WITH GSAP var param = {val:1e-2} TweenMax.to(param, 5, { val:(360-1e-2), repeat: 4, yoyo: true, onUpdate:applyValue, onUpdateParams:[param.val] }) function applyValue (val){ var angle = param.val*3.14/180 var x = a*Math.cos(angle) var y = a*Math.sin(angle) p3.setData(x,a/2+y,0) }; × Search results Close "},"tutorial-circle3pts.html":{"id":"tutorial-circle3pts.html","title":"Tutorial: Circle through 3 points","body":" grasshopper3d.js Classes GHCompGHParamGHRenderGHSolution Tutorials Arc through 3 pointsCircle through 3 points3D CubeDraggable PointMidpoints Circle through 3 points This tutorial shows a circle going through 3 points. In fact, there exists a unique circle going trough 3 non aligned points. The red points are draggables. The parametric solution is animated with GSAP but the model is still draggable. // SET UP THE PARAMETRIC MODEL var a = 200 var angle = -60*3.14/180 var x = a*Math.cos(angle) var y = a*Math.sin(angle) var s = new GHSolution() var p1 = s.Point(-a,0,0) var p2 = s.Point(0,0,0) var p3 = s.Point(x,y,0) var cp1 = s.PolylineFromPts([p1,p2,p3]) var cp2 = s.Circle3pts(p1,p2,p3) // SET UP THE RENDER var r = new GHRender(600, 400, '#example') var svgply1 = r.Polyline(cp1.polyline).addClass('line') var svgcirc = r.Circle(cp2.circle) var svgp1 = r.Point(p1, 10).addClass('node-red') var svgp2 = r.Point(p2, 10).addClass('node-red') var svgp3 = r.Point(p3, 10).addClass('node-red') var svgp4 = r.Point(cp2.center, 5).addClass('line') // ANIMATE WITH GSAP var param = {val:1e-2} TweenMax.to(param, 2, { val:(180-1e-2), repeat: 5, yoyo: true, onUpdate:applyValue, onUpdateParams:[param.val] }) function applyValue (val){ var angle = param.val*3.14/180 var x = a*Math.cos(angle) var y = a*Math.sin(angle) p3.setData(x,y,0) } × Search results Close "},"tutorial-cube3d.html":{"id":"tutorial-cube3d.html","title":"Tutorial: 3D Cube","body":" grasshopper3d.js Classes GHCompGHParamGHRenderGHSolution Tutorials Arc through 3 pointsCircle through 3 points3D CubeDraggable PointMidpoints 3D Cube 3D cube with projection and rotation viewport. // SET UP THE PARAMETRIC MODEL var s = new GHSolution() var l = 100/2 var vertices = [ s.Point(-l, -l, -l), // Front-Bottom-Left s.Point( l, -l, -l), // Front-Bottom-Right s.Point(-l, -l, l), // Rear-Bottom-Left s.Point( l, -l, l), // Rear-Bottom-Right s.Point(-l, l, -l), // Front-Top-Left s.Point( l, l, -l), // Front-Top-Right s.Point(-l, l, l), // Rear-Top-Left s.Point( l, l, l) // Rear-Top-Right ]; var faces = [ s.PolylineFromPts([vertices[0], vertices[1], vertices[5], vertices[4], vertices[0]]), // Front s.PolylineFromPts([vertices[2], vertices[3], vertices[7], vertices[6], vertices[2]]), // Rear s.PolylineFromPts([vertices[0], vertices[1], vertices[3], vertices[2], vertices[0]]), // Bottom s.PolylineFromPts([vertices[4], vertices[5], vertices[7], vertices[6], vertices[4]]), // Top s.PolylineFromPts([vertices[0], vertices[2], vertices[6], vertices[4], vertices[0]]), // Left s.PolylineFromPts([vertices[1], vertices[3], vertices[7], vertices[5], vertices[1]]) // Right ]; // SET UP THE RENDER var r = new GHRender(600,350,'#example') var angle, a, b, proj, rot, view svgfaces = [] for (var i = 0; i &lt; faces.length; i++) { svgfaces.push(r.Polyline(faces[i].polyline).addClass('cube')) } // isometric perspective matrix angle = 30 * 3.14/180 a = Math.cos(angle); b = Math.sin(angle); proj = new Matrix([ a , 0, a, 0, -b, 1, b, 0, 0 , 0, 0, 0, 0 , 0, 0, 0, ]); // ANIMATE WITH GSAP var param = {val:0} rot = Matrix.rotate(param.val, 0, 0, 1) view = Matrix.multiply(proj, rot) TweenMax.to(param, 2, { val:180, repeat: 5, yoyo: true, onUpdate:applyValue, onUpdateParams:[param.val] }) function applyValue (val){ // rotate the object around z axis angle = param.val * 3.14/180 Matrix.rotate(param.val, 0, 0, 1, rot) Matrix.multiply(proj, rot, view) r.setViewport(view) } × Search results Close "},"tutorial-draggable_point.html":{"id":"tutorial-draggable_point.html","title":"Tutorial: Draggable Point","body":" grasshopper3d.js Classes GHCompGHParamGHRenderGHSolution Tutorials Arc through 3 pointsCircle through 3 points3D CubeDraggable PointMidpoints Draggable Point This is a draggable point. // define a new Solution and add 2 points var s = new GHSolution() var p1 = s.Point(0,0,0) var p2 = s.Point(100,-50,0) // define a new Render 400x400px and add 2 svg circles two each points var r = new GHRender(400,400, '#example') var svg1 = r.Point(p1, 10).addClass('node-red') var svg2 = r.Point(p2, 50).addClass('node-blue') × Search results Close "},"tutorial-midpoints.html":{"id":"tutorial-midpoints.html","title":"Tutorial: Midpoints","body":" grasshopper3d.js Classes GHCompGHParamGHRenderGHSolution Tutorials Arc through 3 pointsCircle through 3 points3D CubeDraggable PointMidpoints Midpoints This is a draggable point. var s = new GHSolution() var p1 = s.Point(-100,50,0) var p2 = s.Point(0,50,0) var p3 = s.Point(100,-100,0) var cp1 = s.MidPoint(p1,p2) var cp2 = s.MidPoint(p2,p3) var cp3 = s.MidPoint(cp1.midpoint,cp2.midpoint) var cp4 = s.PolylineFromPts([p1,p2,p3]) var cp5 = s.PolylineFromPts([cp1.midpoint,cp2.midpoint, cp3.midpoint]) var r = new GHRender(600,400) var svgply1 = r.Polyline(cp4.polyline).addClass('line') var svgply2 = r.Polyline(cp5.polyline).addClass('line') var svgp1 = r.Point(p1, 20).addClass('node-red') var svgp2 = r.Point(p2, 20).addClass('node-red') var svgp3 = r.Point(p3, 20).addClass('node-red') var svgp4 = r.Point(cp1.midpoint, 10).addClass('node-blue') var svgp5 = r.Point(cp2.midpoint, 10).addClass('node-blue') var svgp4 = r.Point(cp3.midpoint, 5).addClass('line') × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
